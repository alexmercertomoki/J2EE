package lintCodeWorkOut;

import java.util.ArrayList;


public class Test {
	public static void main(String[] args) {
//		
//		ListNode n1 = new ListNode(1);
//		ListNode n2 = new ListNode(2);
//		ListNode n3 = new ListNode(3);
//		ListNode n4 = new ListNode(4);
//
//		n1.next = n2;
//		n2.next = n3;
//		n3.next = n4;
//		
//		DeleteNodeInTheMiddle dm = new DeleteNodeInTheMiddle();
//		dm.deleteNode(n1);
//		
//		KthLarge k = new KthLarge();
//		ArrayList<Integer> numbers = new ArrayList<Integer>();
////		for(int i = 0; i < 10; i++) {
////			numbers.add(i);
////		}
//		
//		numbers.add(4);
//		numbers.add(3);
//		numbers.add(-1);
//		numbers.add(-2);
//		numbers.add(1);
//		numbers.add(0);
		
		
//		int kth = k.kthLargestElement(2, numbers);
//		System.out.println(kth);
		
//		int index = k.partition(numbers, 0, 3);
//		System.out.println(index);
		
//		maxSubArr ms = new maxSubArr();
//		ArrayList<Integer> list = new ArrayList<Integer>();
//		list.add(-1);
//		list.add(2);
//		list.add(3);
//		list.add(4);
//		int i =ms.maxSubArray(list);
//		System.out.println(i);
		
//		KthLarge2 k2 = new KthLarge2();
//		int[] nums = {1,2,3,4,5,6,8,9,10,7};
//		int num = k2.kthLargestElement(10, nums);
//		System.out.println(num);
//		
//		int[] numbers = {1};
//		numbers[0] ^= numbers[0];
//		numbers[0] ^= numbers[0];
//		numbers[0] ^= numbers[0];
//		
//		System.out.println(numbers[0]);
//		
//		int i = 1, j = 1;
//		i ^= j;
//		j ^= i;
//		i ^= j;
//		System.out.println(i+" "+j);
		
//		SubArrayDifference sad = new SubArrayDifference();
//		int[] nums = {-5,3,-4,0,0,0,-1,20,1,1,-1,-1,-1,-1,-1};
//		int test = sad.maxDiffSubArrays(nums);
//		System.out.println(test);
		
		
//		TopKFreqCanNotSortByValue tkf = new TopKFreqCanNotSortByValue();
//		String[] strarr = {"yes", "lint", "code",
//			    "yes", "code", "baby",
//			    "you", "baby", "chrome",
//			    "safari", "lint", "code",
//			    "body", "lint", "code"};
//		String[] strs = tkf.topKFrequentWords(strarr, 3);
//		
//		for(String str : strs) {
//			System.out.println(str);
//		}
		// sort by key 
//		TreeMap<Integer, Integer> tree = new TreeMap<Integer, Integer>();
//		tree.put(1, 0);
//		tree.put(4, 0);
//		tree.put(8, 0);
//		tree.put(9, 0);
//		
//		for(Map.Entry<Integer, Integer> entry : tree.entrySet()) {
//			System.out.println(entry.getKey());
//		}
//		
//		Iterator<Map.Entry<Integer, Integer>> itr = tree.entrySet().iterator();
//		while(itr.hasNext()) {
//			System.out.println(itr.next().getKey());
//		}
		
//		UglyNumber un = new UglyNumber();
//		long res =  un.kthPrimeNumber(3);
//		System.out.println(res);
		
//		MaxTree mt = new MaxTree(); 
//		int[] arr = {1,2,3,4,5,6,7,8,9,10};
//		mt.maxTree(arr);
		
//		int[] nums = {1,1,1};
//		Total_Occurrence_of_Target tot = new Total_Occurrence_of_Target();
//		int res = tot.totalOccurrence(nums, 1);
//		System.out.println(res);
		
//		int[] nums = {1,4,6,10,20};
//		ClosestNumber cn = new ClosestNumber();
//		cn.closestNumber(nums, 221);
		
		
//		TreeNode root = new TreeNode(2);
//		root.left = new TreeNode(3);
//		root.left.left = new TreeNode(4);
//		
//		Complete_Tree ct = new Complete_Tree();
//		System.out.println(ct.isComplete(root));
		
//		boolean flag = false;
//		if(flag && true) {
//			System.out.println(123);
//		}
		
//		MinDepthBinaryTree mdbt = new MinDepthBinaryTree();
//		int min = mdbt.minDepth(root);
//		System.out.println(min);
		
//		ArrayList<ArrayList<Integer>> list = new ArrayList<>();
//		ArrayList<Integer> arr1 = new ArrayList<Integer>();
//		ArrayList<Integer> arr2 = new ArrayList<Integer>();
//		arr1.add(1);
//		arr2.add(2);
//		arr2.add(3);
//		
//		list.add(arr1);
//		list.add(arr2);
//		
//		Triangle tri = new Triangle();
//		tri.minimumTotal(list);
		
//		DPObstacle dst = new DPObstacle();
//		int[][] obstacleGrid = {{0 ,1, 0},{0 , 0, 0},{0,0,0}};
//		dst.uniquePathsWithObstacles(obstacleGrid);
		
//		int[] arr = new int[3]; // initiated all zeros
//		for(int i : arr) {
//			System.out.println(i);
//		}
		
		
		
		
		
		
		
	}
	
	
}
